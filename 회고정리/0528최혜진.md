# JPA (Java Persistence API)란?
자바에서 관계형 데이터베이스를 사용하는 방식을 정의한 **인터페이스**
인터페이스라서 실제 사용하기 위해선 ORM 프레임워크를 추가로 선택해야 한다.
대표적으로 **하이버네이트**(hibernate)를 사용한다.
자바 객체와 데이터베이스를 연결해 데이터를 관리한다. 
객체 지향 도메인 모델과 데이터베이스의 다리 역할을 한다고 이해하면 된다!
#### 하이버네이트란?
하이버네이트는 **JPA 인터페이스를 구현한 구현체이자** 자바용 ORM 프레임워크
내부적으로 JDBC API 를 사용한다.


> **하이버네이트의 목표**
> **자바 객체를 통해 데이터베이스 종류에 상관없이 데이터베이스를 자유자재로 사용할 수 있게 하자**

\- **Gavin King**

## API란?
네트워크에서 API 는 **프로그램 간에 상호작용하기 위한 매개체**

> Q.**다들 식당에 가면 어떻게 하나요? 주방으로 가서 요리를 주문하나요?**

![[Pasted image 20240527221931.png]]

우리가 웹 사이트의 주소를 입력해서 ~ 보여줘 라고 요청을 한다면 API 는 이 요청을 받아서 서버에게 가져다 주고 그럼 서버는 API 가 준 요청을 처리해 결과를 다시 API 에게 전달할 것이다. 그럼 API 는 최종 결과물을 브라우저에 보내 우리가 입력했던 요청에 대한 결과를 화면을 통해 볼 수 있을 것이다.


## ORM이란?
자바의 객체와 데이터베이스를 연결하는 프로그래밍 기법

> Q. **데이터베이스에 age, name 컬럼에 23, 최혜진이라는 값이 들어있다고 생각해보자.**
> **이걸 자바에서 사용하려면?**

ORM 이 있다면 데이터베이스의 값을 마치 객체처럼 사용할 수 있다.
즉, SQL 을 전혀 몰라도 자바 언어로만 데이터베이스에 접근해 원하는 데이터를 가져올 수 있다는 의미이다.

**결론적으로 ,**
**객체와 데이터베이스를 연결해 자바 언어만으로 데이터베이스를 다룰 수 있게 하는 도구가 <span style="background:#ffbb99">ORM </span>인 것이다.**

## JPA 의 중요한 구성 요소!!!!
### 1. Entity
데이터베이스의 테이블과 매핑되는 객체
엔티티는 본질적으로 자바 객체이므로 일반 객체와 다르지 않으나 데이터베이스의 테이블과 직접 연결된다는 아주 특별한 특징이 있어 구분지어 부른다.

<span style="background:#ffbb99">즉, 엔티티는 객체이긴 하지만 데이터베이스에 영향을 미치는 쿼리를 실행하는 객체인 것이다.</span>

### 2. Entity Manager
엔티티를 관리해 데이터베이스와 애플리케이션 사이에서 객체를 생성, 수정, 삭제하는 등의 역할을 한다.
이러한 entity manager 을 만드는 곳이 entity manager factory 이며 영속성 컨텍스트에 저장한다는 특징이 있다.

> Q. **회원 2명이 동시에 회원가입을 하려는 경우 엔티티 매니저는 어떻게 처리를 할까?**

![[Pasted image 20240527234734.png]]

회원 1의 요청에 대해 가입 처리를 할 엔티티 매니저를 엔티티 매니저 팩토리에서 생성하면 이를 통해 가입 처리를 해 데이터베이스에 회원 정보를 저장한다.
회원 2도 위와 마찬가지일 것이다.
회원 1, 2 를 위해 생성된 엔티티 매니저는 필요한 시점에 데이터베이스와 연결한 뒤 쿼리를 할 것이다.

> Q **. 스프링부트 직접 엔티티 매니저 팩토리를 만들어서 관리할까?**

스프링 부트는 내부에서 엔티티 매니저 팩토리를 하나만 생성해서 관리하고  @PersistenceContext 또는 @Autowired 애노테이션을 사용해 엔티티 매니저를 사용한다.

**<span style="background:#ffbb99">그냥!!! 쉽게 엔티티 매니저는 Spring Data JPA 에서 관리하므로 우리가 직접 생성하거나 관리할 필요가 없다고만 기억하면 될거 같다!!</span>**

### 3. 영속성 컨텍스트
위에서 말했듯이 엔티티 매니저는 엔티티를 영속성 컨텍스트에 저장한다는 특징이 있다.
**그렇다면 영속성 컨텍스트가 정확히 뭘까?**
영속성 컨텍스트는 JPA 의 중요한 특징 중 하나로, **엔티티를 관리하는 가상 공간**이다.
이것이 있어서!!! <span style="background:#ffbb99">데이터베이스에서 효과적으로 데이터를 가져올 수 있고, 엔티티를 편하게 사용할 수 있는 것이다.</span>

#### 영속성 컨텍스트 특징
##### 1. 1차 캐시
   캐시의 키는 엔티티의 @Id 애노테이션이 달린 기본키 역할을 하는 식별자이며 값은 엔티티이다.
   ![[Pasted image 20240528103131.png]]
   ```java
Member member = new Member();
member.setId("member1"); 
member.seUsername("회원1");
// 엔티티 영속(1차 캐시 저장)
em.persist(member); //데이터베이스에 새 엔티티를 저장
// 1차 캐시에서 조회
em.find(Member.class, "member1");
```

   엔티티를 조회하면 1차 캐시에서 데이터를 조회하고 값이 있으면 반환한다.
   값이 없으면 데이터베이스에서 조회해 1차 캐시에 저장한 다음 반환한다.
   이를 통해 캐시된 데이터를 조회할 때에는 데이터베이스를 거치지 않아도 되므로 매우 빠르게 데이터를 조회할 수 있다.
   flush 하지 않으면 db에 저장되지 않은 상태!
   flush 를 해줘야 db에 저장된다.
   
##### 2. 쓰기 지연
   트랜잭션을 커밋하기 전까지는 데이터베이스에 실제로 질의문을 보내지 않고 쿼리를 모았다가 트랜잭션을 커밋하면 모았던 쿼리를 한 번에 실행하는 것을 의미한다. 
   
   이를 통해 적당한 묶음으로 쿼리를 요청할 수 있어 데이터베이스 시스템의 부담이 줄어든다.
   
##### 3. 변경 감지
   트랜잭션을 커밋하면 1차 캐시에 저장되어 있는 엔티티 값과 현재 엔티티 값을 비교해 변경된 값이 있다면 변경사항을 감지해 변경된 값을 데이터베이스에 자동으로 반영한다.
   
   이를 통해 적당한 묶음으로 쿼리를 요청할 수 있어 데이터베이스 시스템의 부담이 줄어든다.
   
##### 4. 지연 로딩
   
   쿼리로 요청한 데이터를 애플리케이션에 바로 로딩하는 것이 아니라 필요할 때 쿼리를 날려 데이터를 조회하는 것을 의미한다.

> 이 특징들 갖는 공통점:  모두 데이터베이스의 접근을 최소화해 성능을 높일 수 있다.


# 생각해보기
## UserMain와 UserRun 에서의 출력값 다른 이유는?
persistence.xml 
```xml
<class>com.example.jpa.exam0528.User</class>
```
코드 실행 해보기!!!

UserMain 클래스에서의 코드는 UserDao 를 사용해 두번 findUser 메소드를 호출한다.
UserDao 의 findUser 메소드는 매번 새로운 EntityManager 을 생성한다.
이 경우엔 findUser 메소드를 호출할 때마다 새로운 엔티티 매니저가 생성되고 각 엔티티 매니저는 고유한 영속성 컨텍스트를 갖게 돼 두 번 호출하면 서로 다른 영속성 컨텍스트에서 같은 ID 를 조회하게 돼 findUser 과 findUser2 는 다른 인스턴스가 된다.

반면에, UserRun 클래스에서의 코드는 동일한 entitymanager 인스턴스를 사용하므로, 같은 영속성 컨텍스트를 공유한다. 
따라서 동일한 id를 가진 엔티티를 조회하면 동일한 인스턴스를 반환해 user1 == user2가 출력되는 것이다.

### 해결방법
UserDao 에서 EntityManager 를 매번 새로 생성하는 방식 때문에 동일한 영속성 컨텍스트를 사용하지 않아 동일성을 보장받지 못 한다.
이를 **해결하기 위해 UserDao 가 동일한 Entitymanager 을 재사용하도록 해야 한다.**

```java
public User findUser(Long id){  
EntityManager em= JPAUtil.getEmf().createEntityManager(); //계속 생성  
try{  
User user=em.find(User.class, id); //id 에 해당하는거 조회해주세요.  
em.close();  
return user;  
}finally {  
em.close();  
}  
}
```
위의 코드에서는 계속 새로운 EntityManager 인스턴스를 생성하게 된다! 
이는 각 메서드 호출에서 별도의 EntityManager 를 사용하게 함으로써 메서드가 호출될 때마다 새로운 영속성 컨텍스트가 생성되는 것을 의미한다.
그렇기 때문에 
```java
package com.example.jpa.exam0528;  
  
import jakarta.persistence.EntityManager;  
  
  
public class UserDao {  
private EntityManager em;  
  
public UserDao(EntityManager em) {  
this.em = em;  
}  
  
public User findUser(Long id) {  
return em.find(User.class, id);  
}  
  
public void createUser(User user) {  
try {  
em.getTransaction().begin();  
em.persist(user);  
em.getTransaction().commit();  
} finally {  
em.close();  
}  
}  
}
```
이렇게 바꿔서 영속성 컨텍스트를 재사용하고 성능을 높일 수 있다.
